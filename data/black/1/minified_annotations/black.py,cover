 import ast
 import asyncio
 from abc import ABC, abstractmethod
 from collections import defaultdict
 from concurrent.futures import Executor, ProcessPoolExecutor
 from contextlib import contextmanager
 from datetime import datetime
 from enum import Enum
 from functools import lru_cache, partial, wraps
 import io
 import itertools
 import logging
 from multiprocessing import Manager, freeze_support
 import os
 from pathlib import Path
 import pickle
 import regex as re
 import signal
 import sys
 import tempfile
 import tokenize
 import traceback
 from typing import (
     Any,
     Callable,
     Collection,
     Dict,
     Generator,
     Generic,
     Iterable,
     Iterator,
     List,
     Optional,
     Pattern,
     Sequence,
     Set,
     Tuple,
     Type,
     TypeVar,
     Union,
     cast,
     TYPE_CHECKING,
 )
 from typing_extensions import Final
 from mypy_extensions import mypyc_attr
 
 from appdirs import user_cache_dir
 from dataclasses import dataclass, field, replace
 import click
 import toml
 from typed_ast import ast3, ast27
 from pathspec import PathSpec
 
 # lib2to3 fork
 from blib2to3.pytree import Node, Leaf, type_repr
 from blib2to3 import pygram, pytree
 from blib2to3.pgen2 import driver, token
 from blib2to3.pgen2.grammar import Grammar
 from blib2to3.pgen2.parse import ParseError
 
 from _black_version import version as __version__
 
 if TYPE_CHECKING:
 
 DEFAULT_LINE_LENGTH = 88
 DEFAULT_EXCLUDES = r"/(\.eggs|\.git|\.hg|\.mypy_cache|\.nox|\.tox|\.venv|\.svn|_build|buck-out|build|dist)/"  # noqa: B950
 DEFAULT_INCLUDES = r"\.pyi?$"
 CACHE_DIR = Path(user_cache_dir("black", version=__version__))
 
 STRING_PREFIX_CHARS: Final = "furbFURB"  # All possible string prefix characters.
 
 
 # types
 FileContent = str
 Encoding = str
 NewLine = str
 Depth = int
 NodeType = int
 ParserState = int
 LeafID = int
 StringID = int
 Priority = int
 Index = int
 LN = Union[Leaf, Node]
 Transformer = Callable[["Line", Collection["Feature"]], Iterator["Line"]]
 Timestamp = float
 FileSize = int
 CacheInfo = Tuple[Timestamp, FileSize]
 Cache = Dict[Path, CacheInfo]
 out = partial(click.secho, bold=True, err=True)
 err = partial(click.secho, fg="red", err=True)
 
 pygram.initialize(CACHE_DIR)
 syms = pygram.python_symbols
 
 
 class NothingChanged(UserWarning):
     """Raised when reformatted code is the same as source."""
 
 
 class CannotTransform(Exception):
     """Base class for errors raised by Transformers."""
 
 
 class CannotSplit(CannotTransform):
     """A readable split that fits the allotted line length is impossible."""
 
 
 class InvalidInput(ValueError):
     """Raised when input source code fails all parse attempts."""
 
 
 T = TypeVar("T")
 E = TypeVar("E", bound=Exception)
 
 
 class Ok(Generic[T]):
     def __init__(self, value: T) -> None:
 
     def ok(self) -> T:
 
 
 class Err(Generic[E]):
     def __init__(self, e: E) -> None:
 
     def err(self) -> E:
 
 
 # The 'Result' return type is used to implement an error-handling model heavily
 # influenced by that used by the Rust programming language
 # (see https://doc.rust-lang.org/book/ch09-00-error-handling.html).
 Result = Union[Ok[T], Err[E]]
 TResult = Result[T, CannotTransform]  # (T)ransform Result
 TMatchResult = TResult[Index]
 
 
 class WriteBack(Enum):
     NO = 0
     YES = 1
     DIFF = 2
     CHECK = 3
     COLOR_DIFF = 4
 
     @classmethod
     def from_configuration(
         cls, *, check: bool, diff: bool, color: bool = False
     ) -> "WriteBack":
         if check and not diff:
 
         if diff and color:
 
         return cls.DIFF if diff else cls.YES
 
 
 class Changed(Enum):
     NO = 0
     CACHED = 1
     YES = 2
 
 
 class TargetVersion(Enum):
     PY27 = 2
     PY33 = 3
     PY34 = 4
     PY35 = 5
     PY36 = 6
     PY37 = 7
     PY38 = 8
 
     def is_python2(self) -> bool:
 
 
 PY36_VERSIONS = {TargetVersion.PY36, TargetVersion.PY37, TargetVersion.PY38}
 
 
 class Feature(Enum):
     # All string literals are unicode
     UNICODE_LITERALS = 1
     F_STRINGS = 2
     NUMERIC_UNDERSCORES = 3
     TRAILING_COMMA_IN_CALL = 4
     TRAILING_COMMA_IN_DEF = 5
     # The following two feature-flags are mutually exclusive, and exactly one should be
     # set for every version of python.
     ASYNC_IDENTIFIERS = 6
     ASYNC_KEYWORDS = 7
     ASSIGNMENT_EXPRESSIONS = 8
     POS_ONLY_ARGUMENTS = 9
 
 
 VERSION_TO_FEATURES: Dict[TargetVersion, Set[Feature]] = {
     TargetVersion.PY27: {Feature.ASYNC_IDENTIFIERS},
     TargetVersion.PY33: {Feature.UNICODE_LITERALS, Feature.ASYNC_IDENTIFIERS},
     TargetVersion.PY34: {Feature.UNICODE_LITERALS, Feature.ASYNC_IDENTIFIERS},
     TargetVersion.PY35: {
         Feature.UNICODE_LITERALS,
         Feature.TRAILING_COMMA_IN_CALL,
         Feature.ASYNC_IDENTIFIERS,
     },
     TargetVersion.PY36: {
         Feature.UNICODE_LITERALS,
         Feature.F_STRINGS,
         Feature.NUMERIC_UNDERSCORES,
         Feature.TRAILING_COMMA_IN_CALL,
         Feature.TRAILING_COMMA_IN_DEF,
         Feature.ASYNC_IDENTIFIERS,
     },
     TargetVersion.PY37: {
         Feature.UNICODE_LITERALS,
         Feature.F_STRINGS,
         Feature.NUMERIC_UNDERSCORES,
         Feature.TRAILING_COMMA_IN_CALL,
         Feature.TRAILING_COMMA_IN_DEF,
         Feature.ASYNC_KEYWORDS,
     },
     TargetVersion.PY38: {
         Feature.UNICODE_LITERALS,
         Feature.F_STRINGS,
         Feature.NUMERIC_UNDERSCORES,
         Feature.TRAILING_COMMA_IN_CALL,
         Feature.TRAILING_COMMA_IN_DEF,
         Feature.ASYNC_KEYWORDS,
         Feature.ASSIGNMENT_EXPRESSIONS,
         Feature.POS_ONLY_ARGUMENTS,
     },
 }
 
 
 @dataclass
 class Mode:
     target_versions: Set[TargetVersion] = field(default_factory=set)
     line_length: int = DEFAULT_LINE_LENGTH
     string_normalization: bool = True
     is_pyi: bool = False
 
     def get_cache_key(self) -> str:
         if self.target_versions:
         else:
             version_str = "-"
         parts = [
             version_str,
             str(self.line_length),
             str(int(self.string_normalization)),
             str(int(self.is_pyi)),
         ]
         return ".".join(parts)
 
 
 # Legacy name, left for integrations.
 FileMode = Mode
 
 
 def supports_feature(target_versions: Set[TargetVersion], feature: Feature) -> bool:
 
 
 def find_pyproject_toml(path_search_start: str) -> Optional[str]:
     """Find the absolute filepath to a pyproject.toml if it exists"""
 
 
 def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:
     """Parse a pyproject toml file, pulling out relevant parts for Black
 
     If parsing fails, will raise a toml.TomlDecodeError
     """
     pyproject_toml = toml.load(path_config)
     config = pyproject_toml.get("tool", {}).get("black", {})
     return {k.replace("--", "").replace("-", "_"): v for k, v in config.items()}
 
 
 def read_pyproject_toml(
     ctx: click.Context, param: click.Parameter, value: Optional[str]
 ) -> Optional[str]:
     """Inject Black configuration from "pyproject.toml" into defaults in `ctx`.
 
     Returns the path to a successfully found and read configuration file, None
     otherwise.
     """
     if not value:
 
     try:
         config = parse_pyproject_toml(value)
 
     if not config:
         return None
 
 
 
 
 
 def target_version_option_callback(
     c: click.Context, p: Union[click.Option, click.Parameter], v: Tuple[str, ...]
 ) -> List[TargetVersion]:
     """Compute the target versions from a --target-version flag.
 
     This is its own function because mypy couldn't infer the type correctly
     when it was a lambda, causing mypyc trouble.
     """
     return [TargetVersion[val.upper()] for val in v]
 
 
 @click.command(context_settings=dict(help_option_names=["-h", "--help"]))
 @click.option("-c", "--code", type=str, help="Format the code passed in as a string.")
 @click.option(
     "-l",
     "--line-length",
     type=int,
     default=DEFAULT_LINE_LENGTH,
     help="How many characters per line to allow.",
     show_default=True,
 )
 @click.option(
     "-t",
     "--target-version",
     type=click.Choice([v.name.lower() for v in TargetVersion]),
     callback=target_version_option_callback,
     multiple=True,
     help=(
         "Python versions that should be supported by Black's output. [default: per-file"
         " auto-detection]"
     ),
 )
 @click.option(
     "--py36",
     is_flag=True,
     help=(
         "Allow using Python 3.6-only syntax on all input files.  This will put trailing"
         " commas in function signatures and calls also after *args and **kwargs."
         " Deprecated; use --target-version instead. [default: per-file auto-detection]"
     ),
 )
 @click.option(
     "--pyi",
     is_flag=True,
     help=(
         "Format all input files like typing stubs regardless of file extension (useful"
         " when piping source on standard input)."
     ),
 )
 @click.option(
     "-S",
     "--skip-string-normalization",
     is_flag=True,
     help="Don't normalize string quotes or prefixes.",
 )
 @click.option(
     "--check",
     is_flag=True,
     help=(
         "Don't write the files back, just return the status.  Return code 0 means"
         " nothing would change.  Return code 1 means some files would be reformatted."
         " Return code 123 means there was an internal error."
     ),
 )
 @click.option(
     "--diff",
     is_flag=True,
     help="Don't write the files back, just output a diff for each file on stdout.",
 )
 @click.option(
     "--color/--no-color",
     is_flag=True,
     help="Show colored diff. Only applies when `--diff` is given.",
 )
 @click.option(
     "--fast/--safe",
     is_flag=True,
     help="If --fast given, skip temporary sanity checks. [default: --safe]",
 )
 @click.option(
     "--include",
     type=str,
     default=DEFAULT_INCLUDES,
     help=(
         "A regular expression that matches files and directories that should be"
         " included on recursive searches.  An empty value means all files are included"
         " regardless of the name.  Use forward slashes for directories on all platforms"
         " (Windows, too).  Exclusions are calculated first, inclusions later."
     ),
     show_default=True,
 )
 @click.option(
     "--exclude",
     type=str,
     default=DEFAULT_EXCLUDES,
     help=(
         "A regular expression that matches files and directories that should be"
         " excluded on recursive searches.  An empty value means no paths are excluded."
         " Use forward slashes for directories on all platforms (Windows, too). "
         " Exclusions are calculated first, inclusions later."
     ),
     show_default=True,
 )
 @click.option(
     "-q",
     "--quiet",
     is_flag=True,
     help=(
         "Don't emit non-error messages to stderr. Errors are still emitted; silence"
         " those with 2>/dev/null."
     ),
 )
 @click.option(
     "-v",
     "--verbose",
     is_flag=True,
     help=(
         "Also emit messages to stderr about files that were not changed or were ignored"
         " due to --exclude=."
     ),
 )
 @click.version_option(version=__version__)
 @click.argument(
     "src",
     nargs=-1,
     type=click.Path(
         exists=True, file_okay=True, dir_okay=True, readable=True, allow_dash=True
     ),
     is_eager=True,
 )
 @click.option(
     "--config",
     type=click.Path(
         exists=True,
         file_okay=True,
         dir_okay=False,
         readable=True,
         allow_dash=False,
         path_type=str,
     ),
     is_eager=True,
     callback=read_pyproject_toml,
     help="Read configuration from PATH.",
 )
 @click.pass_context
 def main(
     ctx: click.Context,
     code: Optional[str],
     line_length: int,
     target_version: List[TargetVersion],
     check: bool,
     diff: bool,
     color: bool,
     fast: bool,
     pyi: bool,
     py36: bool,
     skip_string_normalization: bool,
     quiet: bool,
     verbose: bool,
     include: str,
     exclude: str,
     src: Tuple[str, ...],
     config: Optional[str],
 ) -> None:
     """The uncompromising code formatter."""
     write_back = WriteBack.from_configuration(check=check, diff=diff, color=color)
     if target_version:
     elif py36:
     else:
         # We'll autodetect later.
         versions = set()
     mode = Mode(
         target_versions=versions,
         line_length=line_length,
         is_pyi=pyi,
         string_normalization=not skip_string_normalization,
     )
     if config and verbose:
     if code is not None:
     try:
         include_regex = re_compile_maybe_verbose(include)
     try:
         exclude_regex = re_compile_maybe_verbose(exclude)
     report = Report(check=check, diff=diff, quiet=quiet, verbose=verbose)
     root = find_project_root(src)
     sources: Set[Path] = set()
     path_empty(src, quiet, verbose, ctx)
     for s in src:
         p = Path(s)
         if p.is_dir():
             sources.update(
                 gen_python_files_in_dir(
                     p, root, include_regex, exclude_regex, report, get_gitignore(root)
                 )
             )
             # if a file was explicitly given, we don't care about its extension
     if len(sources) == 0:
 
     if len(sources) == 1:
     else:
         reformat_many(
             sources=sources, fast=fast, write_back=write_back, mode=mode, report=report
         )
 
 
 
 def path_empty(
     src: Tuple[str, ...], quiet: bool, verbose: bool, ctx: click.Context
 ) -> None:
     """
     Exit if there is no `src` provided for formatting
     """
     if not src:
 
 
 def reformat_one(
     src: Path, fast: bool, write_back: WriteBack, mode: Mode, report: "Report"
 ) -> None:
     """Reformat a single file under `src` without spawning child processes.
 
     `fast`, `write_back`, and `mode` options are passed to
     :func:`format_file_in_place` or :func:`format_stdin_to_stdout`.
     """
 
 
 def reformat_many(
     sources: Set[Path], fast: bool, write_back: WriteBack, mode: Mode, report: "Report"
 ) -> None:
     """Reformat multiple files using a ProcessPoolExecutor."""
     loop = asyncio.get_event_loop()
     worker_count = os.cpu_count()
     if sys.platform == "win32":
         # Work around https://bugs.python.org/issue26903
     executor = ProcessPoolExecutor(max_workers=worker_count)
 
 
 async def schedule_formatting(
     sources: Set[Path],
     fast: bool,
     write_back: WriteBack,
     mode: Mode,
     report: "Report",
     loop: asyncio.AbstractEventLoop,
     executor: Executor,
 ) -> None:
     """Run formatting of `sources` in parallel using the provided `executor`.
 
     (Use ProcessPoolExecutors for actual parallelism.)
 
     `write_back`, `fast`, and `mode` options are passed to
     :func:`format_file_in_place`.
     """
 
         # For diff output, we need locks to ensure we don't interleave output
         # from different processes.
         # There are no good alternatives for these on Windows.
                 # If the file was written back or was successfully checked as
                 # well-formatted, store this information in the cache.
 
 
 def format_file_in_place(
     src: Path,
     fast: bool,
     mode: Mode,
     write_back: WriteBack = WriteBack.NO,
     lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
 ) -> bool:
     """Format file under `src` path. Return True if changed.
 
     If `write_back` is DIFF, write a diff to stdout. If it is YES, write reformatted
     code to the file.
     `mode` and `fast` options are passed to :func:`format_file_contents`.
     """
 
 
 
 
 
 
 
 def color_diff(contents: str) -> str:
     """Inject the ANSI color codes to the diff."""
 
 
 def wrap_stream_for_windows(
     f: io.TextIOWrapper,
 ) -> Union[io.TextIOWrapper, "colorama.AnsiToWin32.AnsiToWin32"]:
     """
     Wrap the stream in colorama's wrap_stream so colors are shown on Windows.
 
     If `colorama` is not found, then no change is made. If `colorama` does
     exist, then it handles the logic to determine whether or not to change
     things.
     """
 
         # We set `strip=False` so that we can don't have to modify
         # test_express_diff_with_color.
 
         # wrap_stream returns a `colorama.AnsiToWin32.AnsiToWin32` object
         # which does not have a `detach()` method. So we fake one.
 
 
 
 def format_stdin_to_stdout(
     fast: bool, *, write_back: WriteBack = WriteBack.NO, mode: Mode
 ) -> bool:
     """Format file on stdin. Return True if changed.
 
     If `write_back` is YES, write reformatted code back to stdout. If it is DIFF,
     write a diff to stdout. The `mode` argument is passed to
     :func:`format_file_contents`.
     """
 
 
 
 
 def format_file_contents(src_contents: str, *, fast: bool, mode: Mode) -> FileContent:
     """Reformat contents a file and return new contents.
 
     If `fast` is False, additionally confirm that the reformatted code is
     valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
     `mode` is passed to :func:`format_str`.
     """
 
 
 
 
 def format_str(src_contents: str, *, mode: Mode) -> FileContent:
     """Reformat a string and return new contents.
 
     `mode` determines formatting options, such as how many characters per line are
     allowed.  Example:
 
     >>> import black
     >>> print(black.format_str("def f(arg:str='')->None:...", mode=Mode()))
     def f(arg: str = "") -> None:
         ...
 
     A more complex example:
     >>> print(
     ...   black.format_str(
     ...     "def f(arg:str='')->None: hey",
     ...     mode=black.Mode(
     ...       target_versions={black.TargetVersion.PY36},
     ...       line_length=10,
     ...       string_normalization=False,
     ...       is_pyi=False,
     ...     ),
     ...   ),
     ... )
     def f(
         arg: str = '',
     ) -> None:
         hey
 
     """
 
 
 def decode_bytes(src: bytes) -> Tuple[FileContent, Encoding, NewLine]:
     """Return a tuple of (decoded_contents, encoding, newline).
 
     `newline` is either CRLF or LF but `decoded_contents` is decoded with
     universal newlines (i.e. only contains LF).
     """
 
 
 
 def get_grammars(target_versions: Set[TargetVersion]) -> List[Grammar]:
         # No target_version specified, so try all grammars.
             # Python 3.7+
             # Python 3.0-3.6
             # Python 2.7 with future print_function import
             # Python 2.7
 
         # Python 2-only code, so try Python 2 grammars.
             # Python 2.7 with future print_function import
             # Python 2.7
 
     # Python 3-compatible code, so only try Python 3 grammar.
     # If we have to parse both, try to parse async as a keyword first
         # Python 3.7+
         # Python 3.0-3.6
     # At least one of the above branches must have been taken, because every Python
     # version has exactly one of the two 'ASYNC_*' flags
 
 
 def lib2to3_parse(src_txt: str, target_versions: Iterable[TargetVersion] = ()) -> Node:
     """Given a string with source, return the lib2to3 Node."""
 
 
 
 
 
 def lib2to3_unparse(node: Node) -> str:
     """Given a lib2to3 node, return its string representation."""
 
 
 class Visitor(Generic[T]):
     """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
 
     def visit(self, node: LN) -> Iterator[T]:
         """Main method to visit `node` and its children.
 
         It tries to find a `visit_*()` method for the given `node.type`, like
         `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
         If no dedicated `visit_*()` method is found, chooses `visit_default()`
         instead.
 
         Then yields objects of type `T` from the selected visitor.
         """
         # We explicitly branch on whether a visitor exists (instead of
         # using self.visit_default as the default arg to getattr) in order
         # to save needing to create a bound method object and so mypyc can
         # generate a native call to visit_default.
 
     def visit_default(self, node: LN) -> Iterator[T]:
         """Default `visit_*()` implementation. Recurses to children of `node`."""
 
 
 @dataclass
 class DebugVisitor(Visitor[T]):
     tree_depth: int = 0
 
     def visit_default(self, node: LN) -> Iterator[T]:
 
                 # We don't have to handle prefixes for `Node` objects since
                 # that delegates to the first child anyway.
 
     @classmethod
     def show(cls, code: Union[str, Leaf, Node]) -> None:
         """Pretty-print the lib2to3 AST of a given string of `code`.
 
         Convenience method for debugging.
         """
 
 
 WHITESPACE: Final = {token.DEDENT, token.INDENT, token.NEWLINE}
 STATEMENT: Final = {
     syms.if_stmt,
     syms.while_stmt,
     syms.for_stmt,
     syms.try_stmt,
     syms.except_clause,
     syms.with_stmt,
     syms.funcdef,
     syms.classdef,
 }
 STANDALONE_COMMENT: Final = 153
 token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
 LOGIC_OPERATORS: Final = {"and", "or"}
 COMPARATORS: Final = {
     token.LESS,
     token.GREATER,
     token.EQEQUAL,
     token.NOTEQUAL,
     token.LESSEQUAL,
     token.GREATEREQUAL,
 }
 MATH_OPERATORS: Final = {
     token.VBAR,
     token.CIRCUMFLEX,
     token.AMPER,
     token.LEFTSHIFT,
     token.RIGHTSHIFT,
     token.PLUS,
     token.MINUS,
     token.STAR,
     token.SLASH,
     token.DOUBLESLASH,
     token.PERCENT,
     token.AT,
     token.TILDE,
     token.DOUBLESTAR,
 }
 STARS: Final = {token.STAR, token.DOUBLESTAR}
 VARARGS_SPECIALS: Final = STARS | {token.SLASH}
 VARARGS_PARENTS: Final = {
     syms.arglist,
     syms.argument,  # double star in arglist
     syms.trailer,  # single argument to call
     syms.typedargslist,
     syms.varargslist,  # lambdas
 }
 UNPACKING_PARENTS: Final = {
     syms.atom,  # single element of a list or set literal
     syms.dictsetmaker,
     syms.listmaker,
     syms.testlist_gexp,
     syms.testlist_star_expr,
 }
 TEST_DESCENDANTS: Final = {
     syms.test,
     syms.lambdef,
     syms.or_test,
     syms.and_test,
     syms.not_test,
     syms.comparison,
     syms.star_expr,
     syms.expr,
     syms.xor_expr,
     syms.and_expr,
     syms.shift_expr,
     syms.arith_expr,
     syms.trailer,
     syms.term,
     syms.power,
 }
 ASSIGNMENTS: Final = {
     "=",
     "+=",
     "-=",
     "*=",
     "@=",
     "/=",
     "%=",
     "&=",
     "|=",
     "^=",
     "<<=",
     ">>=",
     "**=",
     "//=",
 }
 COMPREHENSION_PRIORITY: Final = 20
 COMMA_PRIORITY: Final = 18
 TERNARY_PRIORITY: Final = 16
 LOGIC_PRIORITY: Final = 14
 STRING_PRIORITY: Final = 12
 COMPARATOR_PRIORITY: Final = 10
 MATH_PRIORITIES: Final = {
     token.VBAR: 9,
     token.CIRCUMFLEX: 8,
     token.AMPER: 7,
     token.LEFTSHIFT: 6,
     token.RIGHTSHIFT: 6,
     token.PLUS: 5,
     token.MINUS: 5,
     token.STAR: 4,
     token.SLASH: 4,
     token.DOUBLESLASH: 4,
     token.PERCENT: 4,
     token.AT: 4,
     token.TILDE: 3,
     token.DOUBLESTAR: 2,
 }
 DOT_PRIORITY: Final = 1
 
 
 @dataclass
 class BracketTracker:
     """Keeps track of brackets on a line."""
 
     depth: int = 0
     bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = field(default_factory=dict)
     delimiters: Dict[LeafID, Priority] = field(default_factory=dict)
     previous: Optional[Leaf] = None
     _for_loop_depths: List[int] = field(default_factory=list)
     _lambda_argument_depths: List[int] = field(default_factory=list)
 
     def mark(self, leaf: Leaf) -> None:
         """Mark `leaf` with bracket-related metadata. Keep track of delimiters.
 
         All leaves receive an int `bracket_depth` field that stores how deep
         within brackets a given leaf is. 0 means there are no enclosing brackets
         that started on this line.
 
         If a leaf is itself a closing bracket, it receives an `opening_bracket`
         field that it forms a pair with. This is a one-directional link to
         avoid reference cycles.
 
         If a leaf is a delimiter (a token on which Black can split the line if
         needed) and it's on depth 0, its `id()` is stored in the tracker's
         `delimiters` field.
         """
 
 
     def any_open_brackets(self) -> bool:
         """Return True if there is an yet unmatched open bracket on the line."""
 
     def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> Priority:
         """Return the highest priority of a delimiter found on the line.
 
         Values are consistent with what `is_split_*_delimiter()` return.
         Raises ValueError on no delimiters.
         """
 
     def delimiter_count_with_priority(self, priority: Priority = 0) -> int:
         """Return the number of delimiters with the given `priority`.
 
         If no `priority` is passed, defaults to max priority on the line.
         """
 
 
     def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
         """In a for loop, or comprehension, the variables are often unpacks.
 
         To avoid splitting on the comma in this situation, increase the depth of
         tokens between `for` and `in`.
         """
 
 
     def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:
         """See `maybe_increment_for_loop_variable` above for explanation."""
 
 
     def maybe_increment_lambda_arguments(self, leaf: Leaf) -> bool:
         """In a lambda expression, there might be more than one argument.
 
         To avoid splitting on the comma in this situation, increase the depth of
         tokens between `lambda` and `:`.
         """
 
 
     def maybe_decrement_after_lambda_arguments(self, leaf: Leaf) -> bool:
         """See `maybe_increment_lambda_arguments` above for explanation."""
 
 
     def get_open_lsqb(self) -> Optional[Leaf]:
         """Return the most recent opening square bracket (if any)."""
 
 
 @dataclass
 class Line:
     """Holds leaves and comments. Can be printed with `str(line)`."""
 
     depth: int = 0
     leaves: List[Leaf] = field(default_factory=list)
     # keys ordered like `leaves`
     comments: Dict[LeafID, List[Leaf]] = field(default_factory=dict)
     bracket_tracker: BracketTracker = field(default_factory=BracketTracker)
     inside_brackets: bool = False
     should_explode: bool = False
 
     def append(self, leaf: Leaf, preformatted: bool = False) -> None:
         """Add a new `leaf` to the end of the line.
 
         Unless `preformatted` is True, the `leaf` will receive a new consistent
         whitespace prefix and metadata applied by :class:`BracketTracker`.
         Trailing commas are maybe removed, unpacked for loop variables are
         demoted from being delimiters.
 
         Inline comments are put aside.
         """
 
             # Note: at this point leaf.prefix should be empty except for
             # imports, for which we only preserve newlines.
 
     def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
         """Like :func:`append()` but disallow invalid standalone comment structure.
 
         Raises ValueError when any `leaf` is appended after a standalone comment
         or when a standalone comment is not the first leaf on the line.
         """
 
 
 
     @property
     def is_comment(self) -> bool:
         """Is this line a standalone comment?"""
 
     @property
     def is_decorator(self) -> bool:
         """Is this line a decorator?"""
 
     @property
     def is_import(self) -> bool:
         """Is this an import line?"""
 
     @property
     def is_class(self) -> bool:
         """Is this line a class definition?"""
 
     @property
     def is_stub_class(self) -> bool:
         """Is this line a class definition with a body consisting only of "..."?"""
 
     @property
     def is_collection_with_optional_trailing_comma(self) -> bool:
         """Is this line a collection literal with a trailing comma that's optional?
 
         Note that the trailing comma in a 1-tuple is not optional.
         """
 
         # Look for and address a trailing colon.
 
             # Tuples require an extra check, because if there's only
             # one element in the tuple removing the comma unmakes the
             # tuple.
             #
             # We also check for parens before looking for the trailing
             # comma because in some cases (eg assigning a dict
             # literal) the literal gets wrapped in temporary parens
             # during parsing. This case is covered by the
             # collections.py test data.
 
                 # Couldn't find the matching opening paren, play it safe.
 
                 # We haven't looked yet for the trailing comma because
                 # we might also have caught noop parens.
 
 
                     # TODO: this is a gut feeling. Will we ever see this?
 
 
 
     @property
     def is_def(self) -> bool:
         """Is this a function definition? (Also returns True for async defs.)"""
 
 
     @property
     def is_class_paren_empty(self) -> bool:
         """Is this a class with no base classes but using parentheses?
 
         Those are unnecessary and should be removed.
         """
 
     @property
     def is_triple_quoted_string(self) -> bool:
         """Is the line a triple quoted string?"""
 
     def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
         """If so, needs to be split before emitting."""
 
 
     def contains_uncollapsable_type_comments(self) -> bool:
                 # When trailing commas or optional parens are inserted by Black for
                 # consistency, comments after the previous last element are not moved
                 # (they don't have to, rendering will still be correct).  So we ignore
                 # trailing commas and invisible.
 
         # A type comment is uncollapsable if it is attached to a leaf
         # that isn't at the end of the line (since that could cause it
         # to get associated to a different argument) or if there are
         # comments before it (since that could cause it to get hidden
         # behind a comment.
 
 
 
     def contains_unsplittable_type_ignore(self) -> bool:
 
         # If a 'type: ignore' is attached to the end of a line, we
         # can't split the line, because we can't know which of the
         # subexpressions the ignore was meant to apply to.
         #
         # We only want this to apply to actual physical lines from the
         # original source, though: we don't want the presence of a
         # 'type: ignore' at the end of a multiline expression to
         # justify pushing it all onto one line. Thus we
         # (unfortunately) need to check the actual source lines and
         # only report an unsplittable 'type: ignore' if this line was
         # one line in the original code.
 
         # Grab the first and last line numbers, skipping generated leaves
 
             # We look at the last two leaves since a comma or an
             # invisible paren could have been added at the end of the
             # line.
 
 
     def contains_multiline_strings(self) -> bool:
 
     def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
         """Remove trailing comma if there is one and it's safe."""
 
         # We remove trailing commas only in the case of importing a
         # single name from a module.
                 # regular `from foo import bar,`
                 # `from foo import (bar as baz,)
                 # `from foo import bar as baz,`
 
 
     def append_comment(self, comment: Leaf) -> bool:
         """Add an inline or standalone comment to the line."""
 
 
 
             # Comments on an optional parens wrapping a single leaf should belong to
             # the wrapped node except if it's a type comment. Pinning the comment like
             # this avoids unstable formatting caused by comment migration.
 
 
     def comments_after(self, leaf: Leaf) -> List[Leaf]:
         """Generate comments that should appear directly after `leaf`."""
 
     def remove_trailing_comma(self) -> None:
         """Remove the trailing comma and moves the comments attached to it."""
 
     def is_complex_subscript(self, leaf: Leaf) -> bool:
         """Return True iff `leaf` is part of a slice with non-trivial exprs."""
 
 
 
 
     def clone(self) -> "Line":
 
     def __str__(self) -> str:
         """Render the line."""
 
 
 
     def __bool__(self) -> bool:
         """Return True if the line has leaves or comments."""
 
 
 @dataclass
 class EmptyLineTracker:
     """Provides a stateful method that returns the number of potential extra
     empty lines needed before and after the currently processed line.
 
     Note: this tracker works on lines that haven't been split yet.  It assumes
     the prefix of the first leaf consists of optional newlines.  Those newlines
     are consumed by `maybe_empty_lines()` and included in the computation.
     """
 
     is_pyi: bool = False
     previous_line: Optional[Line] = None
     previous_after: int = 0
     previous_defs: List[int] = field(default_factory=list)
 
     def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
         """Return the number of extra empty lines before and after the `current_line`.
 
         This is for separating `def`, `async def` and `class` with extra empty
         lines (two on module-level).
         """
             # Black should not insert empty lines at the beginning
             # of the file
 
     def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
             # Consume the first leaf's extra newlines.
 
 
 
 
     def _maybe_empty_lines_for_class_or_def(
         self, current_line: Line, before: int
     ) -> Tuple[int, int]:
             # Don't insert empty lines before the first line in the file.
 
 
 
 
                     # No blank line between classes with an empty body
                 # Blank line between a block of functions and a block of non-functions
 
 
 @dataclass
 class LineGenerator(Visitor[Line]):
     """Generates reformatted Line objects.  Empty lines are not emitted.
 
     Note: destroys the tree it's visiting by mutating prefixes of its leaves
     in ways that will no longer stringify to valid Python code on the tree.
     """
 
     is_pyi: bool = False
     normalize_strings: bool = True
     current_line: Line = field(default_factory=Line)
     remove_u_prefix: bool = False
 
     def line(self, indent: int = 0) -> Iterator[Line]:
         """Generate a line.
 
         If the line is empty, only emit if it makes sense.
         If the line is too long, split it first and then generate.
 
         If any lines were generated, set up a new current_line.
         """
 
 
     def visit_default(self, node: LN) -> Iterator[Line]:
         """Default `visit_*()` implementation. Recurses to children of `node`."""
                     # any comment within brackets is subject to splitting
                     # regular trailing comment
 
                     # regular standalone comment
 
 
 
     def visit_INDENT(self, node: Leaf) -> Iterator[Line]:
         """Increase indentation level, maybe yield a line."""
         # In blib2to3 INDENT never holds comments.
 
     def visit_DEDENT(self, node: Leaf) -> Iterator[Line]:
         """Decrease indentation level, maybe yield a line."""
         # The current line might still wait for trailing comments.  At DEDENT time
         # there won't be any (they would be prefixes on the preceding NEWLINE).
         # Emit the line then.
 
         # While DEDENT has no value, its prefix may contain standalone comments
         # that belong to the current indentation level.  Get 'em.
 
         # Finally, emit the dedent.
 
     def visit_stmt(
         self, node: Node, keywords: Set[str], parens: Set[str]
     ) -> Iterator[Line]:
         """Visit a statement.
 
         This implementation is shared for `if`, `while`, `for`, `try`, `except`,
         `def`, `with`, `class`, `assert` and assignments.
 
         The relevant Python language `keywords` for a given statement will be
         NAME leaves within it. This methods puts those on a separate line.
 
         `parens` holds a set of string leaf values immediately after which
         invisible parens should be put.
         """
 
 
     def visit_suite(self, node: Node) -> Iterator[Line]:
         """Visit a suite."""
 
     def visit_simple_stmt(self, node: Node) -> Iterator[Line]:
         """Visit a statement without nested statements."""
 
 
     def visit_async_stmt(self, node: Node) -> Iterator[Line]:
         """Visit `async def`, `async for`, `async with`."""
 
 
 
 
     def visit_decorators(self, node: Node) -> Iterator[Line]:
         """Visit decorators."""
 
     def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:
         """Remove a semicolon and put the other statement on a separate line."""
 
     def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
         """End of file. Process outstanding comments and end with a newline."""
 
     def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
 
     def visit_factor(self, node: Node) -> Iterator[Line]:
         """Force parentheses between a unary op and a binary power:
 
         -2 ** 8 -> -(2 ** 8)
         """
 
     def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:
         # Check if it's a docstring
 
 
     def __post_init__(self) -> None:
         """You are in a twisty little maze of passages."""
 
 
 IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
 BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}
 OPENING_BRACKETS = set(BRACKET.keys())
 CLOSING_BRACKETS = set(BRACKET.values())
 BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS
 ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
 
 
 def whitespace(leaf: Leaf, *, complex_subscript: bool) -> str:  # noqa: C901
     """Return whitespace prefix if needed for the given `leaf`.
 
     `complex_subscript` signals whether the given leaf is part of a subscription
     which has non-trivial arguments, like arithmetic expressions or function calls.
     """
 
 
 
 
 
 
 
 
                     # A bit hacky: if the equal sign has whitespace, it means we
                     # previously found it's a typed argument.  So, we're using
                     # that, too.
 
 
 
 
             # Python 2 print chevron
 
 
         # untyped function signatures or calls
 
         # lambdas
 
         # typed function signatures
 
 
             # A bit hacky: if the equal sign has whitespace, it means we
             # previously found it's a typed argument.  So, we're using that, too.
 
 
         # type names
 
         # attributes and calls
 
 
 
 
         # single argument
 
 
 
         # decorators
 
 
 
 
 
         # indexing
 
 
 
             # dots, but not the first one.
 
         # dict unpacking
 
         # unary ops
 
 
 
 
 
 
 
 
 
 
 def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:
     """Return the first leaf that precedes `node`, if any."""
 
 
 
 
 
 def prev_siblings_are(node: Optional[LN], tokens: List[Optional[NodeType]]) -> bool:
     """Return if the `node` and its previous siblings match types against the provided
     list of tokens; the provided `node`has its type matched against the last element in
     the list.  `None` can be used as the first element to declare that the start of the
     list is anchored at the start of its parent's children."""
 
 
 def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
     """Return the child of `ancestor` that contains `descendant`."""
 
 
 def container_of(leaf: Leaf) -> LN:
     """Return `leaf` or one of its ancestors that is the topmost container of it.
 
     By "container" we mean a node where `leaf` is the very first child.
     """
 
 
 
 
 
 
 def is_split_after_delimiter(leaf: Leaf, previous: Optional[Leaf] = None) -> Priority:
     """Return the priority of the `leaf` delimiter, given a line break after it.
 
     The delimiter priorities returned here are from those delimiters that would
     cause a line break after themselves.
 
     Higher numbers are higher priority.
     """
 
 
 
 def is_split_before_delimiter(leaf: Leaf, previous: Optional[Leaf] = None) -> Priority:
     """Return the priority of the `leaf` delimiter, given a line break before it.
 
     The delimiter priorities returned here are from those delimiters that would
     cause a line break before themselves.
 
     Higher numbers are higher priority.
     """
         # * and ** might also be MATH_OPERATORS but in this case they are not.
         # Don't treat them as a delimiter.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
 FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
 
 
 def generate_comments(leaf: LN) -> Iterator[Leaf]:
     """Clean the prefix of the `leaf` and generate comments from it, if any.
 
     Comments in lib2to3 are shoved into the whitespace prefix.  This happens
     in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
     move because it does away with modifying the grammar to include all the
     possible places in which comments can be placed.
 
     The sad consequence for us though is that comments don't "belong" anywhere.
     This is why this function generates simple parentless Leaf objects for
     comments.  We simply don't know what the correct parent should be.
 
     No matter though, we can live without this.  We really only need to
     differentiate between inline and standalone comments.  The latter don't
     share the line with any code.
 
     Inline comments are emitted as regular token.COMMENT leaves.  Standalone
     are emitted with a fake STANDALONE_COMMENT token identifier.
     """
 
 
 @dataclass
 class ProtoComment:
     """Describes a piece of syntax that is a comment.
 
     It's not a :class:`blib2to3.pytree.Leaf` so that:
 
     * it can be cached (`Leaf` objects should not be reused more than once as
       they store their lineno, column, prefix, and parent information);
     * `newlines` and `consumed` fields are kept separate from the `value`. This
       simplifies handling of special marker comments like ``# fmt: off/on``.
     """
 
     type: int  # token.COMMENT or STANDALONE_COMMENT
     value: str  # content of the comment
     newlines: int  # how many newlines before the comment
     consumed: int  # how many characters of the original leaf's prefix did we consume
 
 
 @lru_cache(maxsize=4096)
 def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
     """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
 
             # Escaped newlines outside of a comment are not really newlines at
             # all. We treat a single-line comment following an escaped newline
             # as a simple trailing comment.
 
 
 
 def make_comment(content: str) -> str:
     """Return a consistently formatted comment from the given `content` string.
 
     All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
     space between the hash sign and the content.
 
     If `content` didn't start with a hash sign, one is provided.
     """
 
 
 
 def transform_line(
     line: Line,
     line_length: int,
     normalize_strings: bool,
     features: Collection[Feature] = (),
 ) -> Iterator[Line]:
     """Transform a `line`, potentially splitting it into many lines.
 
     They should fit in the allotted `line_length` but might not be able to.
 
     `features` are syntactical features that may be used in the output.
     """
 
 
 
 
         # Only apply basic string preprocessing, since lines shouldn't be split here.
 
 
             # All splits failed, best effort split with no omits.
             # This mostly happens to multiline strings that are by definition
             # reported as not fitting a single line.
             # line_length=1 here was historically a bug that somehow became a feature.
             # See #762 and #781 for the full story.
 
 
         # We are accumulating lines in `result` because we might want to abort
         # mission and return the original line in the end, or attempt a different
         # split altogether.
 
 
 
 
 @dataclass  # type: ignore
 class StringTransformer(ABC):
     """
     An implementation of the Transformer protocol that relies on its
     subclasses overriding the template methods `do_match(...)` and
     `do_transform(...)`.
 
     This Transformer works exclusively on strings (for example, by merging
     or splitting them).
 
     The following sections can be found among the docstrings of each concrete
     StringTransformer subclass.
 
     Requirements:
         Which requirements must be met of the given Line for this
         StringTransformer to be applied?
 
     Transformations:
         If the given Line meets all of the above requirments, which string
         transformations can you expect to be applied to it by this
         StringTransformer?
 
     Collaborations:
         What contractual agreements does this StringTransformer have with other
         StringTransfomers? Such collaborations should be eliminated/minimized
         as much as possible.
     """
 
     line_length: int
     normalize_strings: bool
 
     @abstractmethod
     def do_match(self, line: Line) -> TMatchResult:
         """
         Returns:
             * Ok(string_idx) such that `line.leaves[string_idx]` is our target
             string, if a match was able to be made.
                 OR
             * Err(CannotTransform), if a match was not able to be made.
         """
 
     @abstractmethod
     def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:
         """
         Yields:
             * Ok(new_line) where new_line is the new transformed line.
                 OR
             * Err(CannotTransform) if the transformation failed for some reason. The
             `do_match(...)` template method should usually be used to reject
             the form of the given Line, but in some cases it is difficult to
             know whether or not a Line meets the StringTransformer's
             requirements until the transformation is already midway.
 
         Side Effects:
             This method should NOT mutate @line directly, but it MAY mutate the
             Line's underlying Node structure. (WARNING: If the underlying Node
             structure IS altered, then this method should NOT be allowed to
             yield an CannotTransform after that point.)
         """
 
     def __call__(self, line: Line, _features: Collection[Feature]) -> Iterator[Line]:
         """
         StringTransformer instances have a call signature that mirrors that of
         the Transformer type.
 
         Raises:
             CannotTransform(...) if the concrete StringTransformer class is unable
             to transform @line.
         """
         # Optimization to avoid calling `self.do_match(...)` when the line does
         # not contain any string.
 
 
 
 
 
 
 @dataclass
 class CustomSplit:
     """A custom (i.e. manual) string split.
 
     A single CustomSplit instance represents a single substring.
 
     Examples:
         Consider the following string:
         ```
         "Hi there friend."
         " This is a custom"
         f" string {split}."
         ```
 
         This string will correspond to the following three CustomSplit instances:
         ```
         CustomSplit(False, 16)
         CustomSplit(False, 17)
         CustomSplit(True, 16)
         ```
     """
 
     has_prefix: bool
     break_idx: int
 
 
 class CustomSplitMapMixin:
     """
     This mixin class is used to map merged strings to a sequence of
     CustomSplits, which will then be used to re-split the strings iff none of
     the resultant substrings go over the configured max line length.
     """
 
     _Key = Tuple[StringID, str]
     _CUSTOM_SPLIT_MAP: Dict[_Key, Tuple[CustomSplit, ...]] = defaultdict(tuple)
 
     @staticmethod
     def _get_key(string: str) -> "CustomSplitMapMixin._Key":
         """
         Returns:
             A unique identifier that is used internally to map @string to a
             group of custom splits.
         """
 
     def add_custom_splits(
         self, string: str, custom_splits: Iterable[CustomSplit]
     ) -> None:
         """Custom Split Map Setter Method
 
         Side Effects:
             Adds a mapping from @string to the custom splits @custom_splits.
         """
 
     def pop_custom_splits(self, string: str) -> List[CustomSplit]:
         """Custom Split Map Getter Method
 
         Returns:
             * A list of the custom splits that are mapped to @string, if any
             exist.
                 OR
             * [], otherwise.
 
         Side Effects:
             Deletes the mapping between @string and its associated custom
             splits (which are returned to the caller).
         """
 
 
 
     def has_custom_splits(self, string: str) -> bool:
         """
         Returns:
             True iff @string is associated with a set of custom splits.
         """
 
 
 class StringMerger(CustomSplitMapMixin, StringTransformer):
     """StringTransformer that merges strings together.
 
     Requirements:
         (A) The line contains adjacent strings such that at most one substring
         has inline comments AND none of those inline comments are pragmas AND
         the set of all substring prefixes is either of length 1 or equal to
         {"", "f"} AND none of the substrings are raw strings (i.e. are prefixed
         with 'r').
             OR
         (B) The line contains a string which uses line continuation backslashes.
 
     Transformations:
         Depending on which of the two requirements above where met, either:
 
         (A) The string group associated with the target string is merged.
             OR
         (B) All line-continuation backslashes are removed from the target string.
 
     Collaborations:
         StringMerger provides custom split information to StringSplitter.
     """
 
     def do_match(self, line: Line) -> TMatchResult:
 
 
 
 
 
     def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:
 
 
 
             # Chain the errors together using `__cause__`.
 
 
     @staticmethod
     def __remove_backslash_line_continuation_chars(
         line: Line, string_idx: int
     ) -> TResult[Line]:
         """
         Merge strings that were split across multiple lines using
         line-continuation backslashes.
 
         Returns:
             Ok(new_line), if @line contains backslash line-continuation
             characters.
                 OR
             Err(CannotTransform), otherwise.
         """
 
 
 
 
 
     def __merge_string_group(self, line: Line, string_idx: int) -> TResult[Line]:
         """
         Merges string group (i.e. set of adjacent strings) where the first
         string in the group is `line.leaves[string_idx]`.
 
         Returns:
             Ok(new_line), if ALL of the validation checks found in
             __validate_msg(...) pass.
                 OR
             Err(CannotTransform), otherwise.
         """
 
 
 
         # If the string group is wrapped inside an Atom node, we must make sure
         # to later replace that Atom with our new (merged) string leaf.
 
         # We will place BREAK_MARK in between every two substrings that we
         # merge. We will then later go through our final result and use the
         # various instances of BREAK_MARK we find to add the right values to
         # the custom split map.
 
 
 
 
 
 
         # Holds the CustomSplit objects that will later be added to the custom
         # split map.
 
         # Temporary storage for the 'has_prefix' part of the CustomSplit objects.
 
         # Sets the 'prefix' variable. This is the prefix that the final merged
         # string will have.
 
         # The next loop merges the string group. The final string will be
         # contained in 'S'.
         #
         # The following convenience variables are used:
         #
         #   S: string
         #   NS: naked string
         #   SS: next string
         #   NSS: naked next string
 
 
             # If this is an f-string group but this substring is not prefixed
             # with 'f'...
                 # Then we must escape any braces contained in this substring.
 
 
 
 
 
 
         # Fill the 'custom_splits' list with the appropriate CustomSplit objects.
 
 
 
 
         # Build the final line ('new_line') that this method will later return.
 
 
 
 
     @staticmethod
     def __validate_msg(line: Line, string_idx: int) -> TResult[None]:
         """Validate (M)erge (S)tring (G)roup
 
         Transform-time string validation logic for __merge_string_group(...).
 
         Returns:
             * Ok(None), if ALL validation checks (listed below) pass.
                 OR
             * Err(CannotTransform), if any of the following are true:
                 - The target string is not in a string group (i.e. it has no
                   adjacent strings).
                 - The string group has more than one inline comment.
                 - The string group has an inline comment that appears to be a pragma.
                 - The set of all string prefixes in the string group is of
                   length greater than one and is not equal to {"", "f"}.
                 - The string group consists of raw strings.
         """
                 # If the string group is trailed by a comma, we count the
                 # comments trailing the comma to be one of the string group's
                 # comments.
 
 
 
 
 
 
 
 
 
 
 class StringParenStripper(StringTransformer):
     """StringTransformer that strips surrounding parentheses from strings.
 
     Requirements:
         The line contains a string which is surrounded by parentheses and:
             - The target string is NOT the only argument to a function call).
             - The RPAR is NOT followed by an attribute access (i.e. a dot).
 
     Transformations:
         The parentheses mentioned in the 'Requirements' section are stripped.
 
     Collaborations:
         StringParenStripper has its own inherent usefulness, but it is also
         relied on to clean up the parentheses created by StringParenWrapper (in
         the event that they are no longer needed).
     """
 
     def do_match(self, line: Line) -> TMatchResult:
 
 
             # Should be a string...
 
             # Should be preceded by a non-empty LPAR...
 
             # That LPAR should NOT be preceded by a function name or a closing
             # bracket (which could be a function which returns a function or a
             # list/dictionary that contains a function)...
 
 
             # Skip the string trailer, if one exists.
 
             # Should be followed by a non-empty RPAR...
                 # That RPAR should NOT be followed by a '.' symbol.
 
 
 
     def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:
 
 
 
 
 
 
 
 
 
 
 class BaseStringSplitter(StringTransformer):
     """
     Abstract class for StringTransformers which transform a Line's strings by splitting
     them or placing them on their own lines where necessary to avoid going over
     the configured line length.
 
     Requirements:
         * The target string value is responsible for the line going over the
         line length limit. It follows that after all of black's other line
         split methods have been exhausted, this line (or one of the resulting
         lines after all line splits are performed) would still be over the
         line_length limit unless we split this string.
             AND
         * The target string is NOT a "pointless" string (i.e. a string that has
         no parent or siblings).
             AND
         * The target string is not followed by an inline comment that appears
         to be a pragma.
             AND
         * The target string is not a multiline (i.e. triple-quote) string.
     """
 
     @abstractmethod
     def do_splitter_match(self, line: Line) -> TMatchResult:
         """
         BaseStringSplitter asks its clients to override this method instead of
         `StringTransformer.do_match(...)`.
 
         Follows the same protocol as `StringTransformer.do_match(...)`.
 
         Refer to `help(StringTransformer.do_match)` for more information.
         """
 
     def do_match(self, line: Line) -> TMatchResult:
 
 
 
     def __validate(self, line: Line, string_idx: int) -> TResult[None]:
         """
         Checks that @line meets all of the requirements listed in this classes'
         docstring. Refer to `help(BaseStringSplitter)` for a detailed
         description of those requirements.
 
         Returns:
             * Ok(None), if ALL of the requirements are met.
                 OR
             * Err(CannotTransform), if ANY of the requirements are NOT met.
         """
 
 
 
 
 
 
 
     def __get_max_string_length(self, line: Line, string_idx: int) -> int:
         """
         Calculates the max string length used when attempting to determine
         whether or not the target string is responsible for causing the line to
         go over the line length limit.
 
         WARNING: This method is tightly coupled to both StringSplitter and
         (especially) StringParenWrapper. There is probably a better way to
         accomplish what is being done here.
 
         Returns:
             max_string_length: such that `line.leaves[string_idx].value >
             max_string_length` implies that the target string IS responsible
             for causing this line to exceed the line length limit.
         """
 
 
         # We use the shorthand "WMA4" in comments to abbreviate "We must
         # account for". When giving examples, we use STRING to mean some/any
         # valid string.
         #
         # Finally, we use the following convenience variables:
         #
         #   P:  The leaf that is before the target string leaf.
         #   N:  The leaf that is after the target string leaf.
         #   NN: The leaf that is after N.
 
         # WMA4 the whitespace at the beginning of the line.
 
                 # If the previous leaf is an empty LPAR placeholder, we should skip it.
 
                 # WMA4 a space and a '+' character (e.g. `+ STRING`).
 
                 # WMA4 a space, a comma, and a closing bracket [e.g. `), STRING`].
 
                 # This conditional branch is meant to handle dictionary keys,
                 # variable assignments, 'return STRING' statement lines, and
                 # 'else STRING' ternary expression lines.
 
                 # WMA4 a single space.
 
                 # WMA4 the lengths of any leaves that came before that space.
 
                 # If the next leaf is an empty RPAR placeholder, we should skip it.
 
                 # WMA4 a single comma at the end of the string (e.g `STRING,`).
 
 
                     # This conditional branch is meant to handle method calls invoked
                     # off of a string literal up to and including the LPAR character.
 
                     # WMA4 the '.' character.
 
                         # WMA4 the left parenthesis character.
 
                     # WMA4 the length of the method's name.
 
                 # WMA4 two spaces before the '#' character.
 
             # WMA4 the length of the inline comment.
 
 
 
 class StringSplitter(CustomSplitMapMixin, BaseStringSplitter):
     """
     StringTransformer that splits "atom" strings (i.e. strings which exist on
     lines by themselves).
 
     Requirements:
         * The line consists ONLY of a single string (with the exception of a
         '+' symbol which MAY exist at the start of the line), MAYBE a string
         trailer, and MAYBE a trailing comma.
             AND
         * All of the requirements listed in BaseStringSplitter's docstring.
 
     Transformations:
         The string mentioned in the 'Requirements' section is split into as
         many substrings as necessary to adhere to the configured line length.
 
         In the final set of substrings, no substring should be smaller than
         MIN_SUBSTR_SIZE characters.
 
         The string will ONLY be split on spaces (i.e. each new substring should
         start with a space).
 
         If the string is an f-string, it will NOT be split in the middle of an
         f-expression (e.g. in f"FooBar: {foo() if x else bar()}", {foo() if x
         else bar()} is an f-expression).
 
         If the string that is being split has an associated set of custom split
         records and those custom splits will NOT result in any line going over
         the configured line length, those custom splits are used. Otherwise the
         string is split as late as possible (from left-to-right) while still
         adhering to the transformation rules listed above.
 
     Collaborations:
         StringSplitter relies on StringMerger to construct the appropriate
         CustomSplit objects and add them to the custom split map.
     """
 
     MIN_SUBSTR_SIZE = 6
     # Matches an "f-expression" (e.g. {var}) that might be found in an f-string.
     RE_FEXPR = r"""
     (?<!\{)\{
         (?:
             [^\{\}]
             | \{\{
             | \}\}
         )+?
     (?<!\})(?:\}\})*\}(?!\})
     """
 
     def do_splitter_match(self, line: Line) -> TMatchResult:
 
 
 
         # The first leaf MAY be a '+' symbol...
 
         # The next/first leaf MAY be an empty LPAR...
 
         # The next/first leaf MUST be a string...
 
 
         # Skip the string trailer, if one exists.
 
         # That string MAY be followed by an empty RPAR...
 
         # That string / empty RPAR leaf MAY be followed by a comma...
 
         # But no more leaves are allowed...
 
 
     def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:
 
 
 
 
         # We MAY choose to drop the 'f' prefix from substrings that don't
         # contain any f-expressions, but ONLY if the original f-string
         # containes at least one f-expression. Otherwise, we will alter the AST
         # of the program.
 
 
 
 
 
 
         # --- Calculate Max Break Index (for string value)
         # We start with the line length limit
         # The last index of a string of length N is N-1.
         # Leading whitespace is not present in the string value (e.g. Leaf.value).
 
         # Check if StringMerger registered any custom splits.
         # We use them ONLY if none of them would produce lines that exceed the
         # line limit.
 
         # Temporary storage for the remaining chunk of the string line that
         # can't fit onto the line currently being constructed.
 
 
                 # Custom User Split (manual)
                 # Algorithmic Split (automatic)
                     # If we are unable to algorthmically determine a good split
                     # and this string has custom splits registered to it, we
                     # fall back to using them--which means we have to start
                     # over from the beginning.
 
                     # Otherwise, we stop splitting here.
 
 
             # --- Construct `next_value`
                 # Are we allowed to try to drop a pointless 'f' prefix?
                 # If we are, will we be successful?
                 # If the current custom split did NOT originally use a prefix,
                 # then `csplit.break_idx` will be off by one after removing
                 # the 'f' prefix.
 
             # --- Construct `next_leaf`
 
             # --- Construct `next_line`
 
 
 
 
 
         # NOTE: I could not find a test case that verifies that the following
         # line is actually necessary, but it seems to be. Otherwise we risk
         # not normalizing the last substring, right?
 
 
         # If there are any leaves to the right of the target string...
             # We use `temp_value` here to determine how long the last line
             # would be if we were to append all the leaves to the right of the
             # target string to the last string line.
 
             # Try to fit them all on the same line with the last substring...
             # Otherwise, place the last substring on one line and everything
             # else on a line below that...
 
         # Else the target string was the last leaf...
 
     def __get_break_idx(self, string: str, max_break_idx: int) -> Optional[int]:
         """
         This method contains the algorithm that StringSplitter uses to
         determine which character to split each string at.
 
         Args:
             @string: The substring that we are attempting to split.
             @max_break_idx: The ideal break index. We will return this value if it
             meets all the necessary conditions. In the likely event that it
             doesn't we will try to find the closest index BELOW @max_break_idx
             that does. If that fails, we will expand our search by also
             considering all valid indices ABOVE @max_break_idx.
 
         Pre-Conditions:
             * assert_is_leaf_string(@string)
             * 0 <= @max_break_idx < len(@string)
 
         Returns:
             break_idx, if an index is able to be found that meets all of the
             conditions listed in the 'Transformations' section of this classes'
             docstring.
                 OR
             None, otherwise.
         """
 
 
 
 
 
 
 
 
 
 
 
         # First, we check all indices BELOW @max_break_idx.
 
             # If that fails, we check all indices ABOVE @max_break_idx.
             #
             # If we are able to find a valid index here, the next line is going
             # to be longer than the specified line length, but it's probably
             # better than doing nothing at all.
 
 
 
     def __maybe_normalize_string_quotes(self, leaf: Leaf) -> None:
 
     def __normalize_f_string(self, string: str, prefix: str) -> str:
         """
         Pre-Conditions:
             * assert_is_leaf_string(@string)
 
         Returns:
             * If @string is an f-string that contains no f-expressions, we
             return a string identical to @string except that the 'f' prefix
             has been stripped and all double braces (i.e. '{{' or '}}') have
             been normalized (i.e. turned into '{' or '}').
                 OR
             * Otherwise, we return @string.
         """
 
 
 
 
 
 class StringParenWrapper(CustomSplitMapMixin, BaseStringSplitter):
     """
     StringTransformer that splits non-"atom" strings (i.e. strings that do not
     exist on lines by themselves).
 
     Requirements:
         All of the requirements listed in BaseStringSplitter's docstring in
         addition to the requirements listed below:
 
         * The line is a return/yield statement, which returns/yields a string.
             OR
         * The line is part of a ternary expression (e.g. `x = y if cond else
         z`) such that the line starts with `else <string>`, where <string> is
         some string.
             OR
         * The line is an assert statement, which ends with a string.
             OR
         * The line is an assignment statement (e.g. `x = <string>` or `x +=
         <string>`) such that the variable is being assigned the value of some
         string.
             OR
         * The line is a dictionary key assignment where some valid key is being
         assigned the value of some string.
 
     Transformations:
         The chosen string is wrapped in parentheses and then split at the LPAR.
 
         We then have one line which ends with an LPAR and another line that
         starts with the chosen string. The latter line is then split again at
         the RPAR. This results in the RPAR (and possibly a trailing comma)
         being placed on its own line.
 
         NOTE: If any leaves exist to the right of the chosen string (except
         for a trailing comma, which would be placed after the RPAR), those
         leaves are placed inside the parentheses.  In effect, the chosen
         string is not necessarily being "wrapped" by parentheses. We can,
         however, count on the LPAR being placed directly before the chosen
         string.
 
         In other words, StringParenWrapper creates "atom" strings. These
         can then be split again by StringSplitter, if necessary.
 
     Collaborations:
         In the event that a string line split by StringParenWrapper is
         changed such that it no longer needs to be given its own line,
         StringParenWrapper relies on StringParenStripper to clean up the
         parentheses it created.
     """
 
     def do_splitter_match(self, line: Line) -> TMatchResult:
 
 
             # If the string has no spaces...
                 # And will still violate the line length limit when split...
                     # And has no associated custom splits...
                         # Then we should NOT put this string on its own line.
 
 
     @staticmethod
     def _return_match(LL: List[Leaf]) -> Optional[int]:
         """
         Returns:
             string_idx such that @LL[string_idx] is equal to our target (i.e.
             matched) string, if this line matches the return/yield statement
             requirements listed in the 'Requirements' section of this classes'
             docstring.
                 OR
             None, otherwise.
         """
         # If this line is apart of a return/yield statement and the first leaf
         # contains either the "return" or "yield" keywords...
 
             # The next visible leaf MUST contain a string...
 
 
     @staticmethod
     def _else_match(LL: List[Leaf]) -> Optional[int]:
         """
         Returns:
             string_idx such that @LL[string_idx] is equal to our target (i.e.
             matched) string, if this line matches the ternary expression
             requirements listed in the 'Requirements' section of this classes'
             docstring.
                 OR
             None, otherwise.
         """
         # If this line is apart of a ternary expression and the first leaf
         # contains the "else" keyword...
 
             # The next visible leaf MUST contain a string...
 
 
     @staticmethod
     def _assert_match(LL: List[Leaf]) -> Optional[int]:
         """
         Returns:
             string_idx such that @LL[string_idx] is equal to our target (i.e.
             matched) string, if this line matches the assert statement
             requirements listed in the 'Requirements' section of this classes'
             docstring.
                 OR
             None, otherwise.
         """
         # If this line is apart of an assert statement and the first leaf
         # contains the "assert" keyword...
 
                 # We MUST find a comma...
 
                     # That comma MUST be followed by a string...
 
                         # Skip the string trailer, if one exists.
 
                         # But no more leaves are allowed...
 
 
     @staticmethod
     def _assign_match(LL: List[Leaf]) -> Optional[int]:
         """
         Returns:
             string_idx such that @LL[string_idx] is equal to our target (i.e.
             matched) string, if this line matches the assignment statement
             requirements listed in the 'Requirements' section of this classes'
             docstring.
                 OR
             None, otherwise.
         """
         # If this line is apart of an expression statement or is a function
         # argument AND the first leaf contains a variable name...
 
                 # We MUST find either an '=' or '+=' symbol...
 
                     # That symbol MUST be followed by a string...
 
                         # Skip the string trailer, if one exists.
 
                         # The next leaf MAY be a comma iff this line is apart
                         # of a function argument...
 
                         # But no more leaves are allowed...
 
 
     @staticmethod
     def _dict_match(LL: List[Leaf]) -> Optional[int]:
         """
         Returns:
             string_idx such that @LL[string_idx] is equal to our target (i.e.
             matched) string, if this line matches the dictionary key assignment
             statement requirements listed in the 'Requirements' section of this
             classes' docstring.
                 OR
             None, otherwise.
         """
         # If this line is apart of a dictionary key assignment...
 
                 # We MUST find a colon...
 
                     # That colon MUST be followed by a string...
 
                         # Skip the string trailer, if one exists.
 
                         # That string MAY be followed by a comma...
 
                         # But no more leaves are allowed...
 
 
     def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:
 
 
 
 
         # --- First Line
 
         # We have to remember to account for (possibly invisible) LPAR and RPAR
         # leaves that already wrapped the target string. If these leaves do
         # exist, we will replace them with our own LPAR and RPAR leaves.
 
 
 
         # We throw inline comments that were originally to the right of the
         # target string to the top line. They will now be shown to the right of
         # the LPAR.
 
 
         # --- Middle (String) Line
         # We only need to yield one (possibly too long) string line, since the
         # `StringSplitter` will break it down further if necessary.
 
 
 
 
 
         # --- Last Line
 
 
         # If the target string ended with a comma, we place this comma to the
         # right of the RPAR on the last line.
 
 
 
 class StringParser:
     """
     A state machine that aids in parsing a string's "trailer", which can be
     either non-existant, an old-style formatting sequence (e.g. `% varX` or `%
     (varX, varY)`), or a method-call / attribute access (e.g. `.format(varX,
     varY)`).
 
     NOTE: A new StringParser object MUST be instantiated for each string
     trailer we need to parse.
 
     Examples:
         We shall assume that `line` equals the `Line` object that corresponds
         to the following line of python code:
         ```
         x = "Some {}.".format("String") + some_other_string
         ```
 
         Furthermore, we will assume that `string_idx` is some index such that:
         ```
         assert line.leaves[string_idx].value == "Some {}."
         ```
 
         The following code snippet then holds:
         ```
         string_parser = StringParser()
         idx = string_parser.parse(line.leaves, string_idx)
         assert line.leaves[idx].type == token.PLUS
         ```
     """
 
     DEFAULT_TOKEN = -1
 
     # String Parser States
     START = 1
     DOT = 2
     NAME = 3
     PERCENT = 4
     SINGLE_FMT_ARG = 5
     LPAR = 6
     RPAR = 7
     DONE = 8
 
     # Lookup Table for Next State
     _goto: Dict[Tuple[ParserState, NodeType], ParserState] = {
         # A string trailer may start with '.' OR '%'.
         (START, token.DOT): DOT,
         (START, token.PERCENT): PERCENT,
         (START, DEFAULT_TOKEN): DONE,
         # A '.' MUST be followed by an attribute or method name.
         (DOT, token.NAME): NAME,
         # A method name MUST be followed by an '(', whereas an attribute name
         # is the last symbol in the string trailer.
         (NAME, token.LPAR): LPAR,
         (NAME, DEFAULT_TOKEN): DONE,
         # A '%' symbol can be followed by an '(' or a single argument (e.g. a
         # string or variable name).
         (PERCENT, token.LPAR): LPAR,
         (PERCENT, DEFAULT_TOKEN): SINGLE_FMT_ARG,
         # If a '%' symbol is followed by a single argument, that argument is
         # the last leaf in the string trailer.
         (SINGLE_FMT_ARG, DEFAULT_TOKEN): DONE,
         # If present, a ')' symbol is the last symbol in a string trailer.
         # (NOTE: LPARS and nested RPARS are not included in this lookup table,
         # since they are treated as a special case by the parsing logic in this
         # classes' implementation.)
         (RPAR, DEFAULT_TOKEN): DONE,
     }
 
     def __init__(self) -> None:
 
     def parse(self, leaves: List[Leaf], string_idx: int) -> int:
         """
         Pre-conditions:
             * @leaves[@string_idx].type == token.STRING
 
         Returns:
             The index directly after the last leaf which is apart of the string
             trailer, if a "trailer" exists.
                 OR
             @string_idx + 1, if no string "trailer" exists.
         """
 
 
     def _next_state(self, leaf: Leaf) -> bool:
         """
         Pre-conditions:
             * On the first call to this function, @leaf MUST be the leaf that
             was directly after the string leaf in question (e.g. if our target
             string is `line.leaves[i]` then the first call to this method must
             be `line.leaves[i + 1]`).
             * On the next call to this function, the leaf paramater passed in
             MUST be the leaf directly following @leaf.
 
         Returns:
             True iff @leaf is apart of the string's trailer.
         """
         # We ignore empty LPAR or RPAR leaves.
 
 
 
         # The LPAR parser state is a special case. We will return True until we
         # find the matching RPAR token.
         # Otherwise, we use a lookup table to determine the next state.
             # If the lookup table matches the current state to the next
             # token, we use the lookup table.
                 # Otherwise, we check if a the current state was assigned a
                 # default.
                 # If no default has been assigned, then this parser has a logic
                 # error.
 
 
 
 
 def TErr(err_msg: str) -> Err[CannotTransform]:
     """(T)ransform Err
 
     Convenience function used when working with the TResult type.
     """
 
 
 def contains_pragma_comment(comment_list: List[Leaf]) -> bool:
     """
     Returns:
         True iff one of the comments in @comment_list is a pragma used by one
         of the more common static analysis tools for python (e.g. mypy, flake8,
         pylint).
     """
 
 
 
 def insert_str_child_factory(string_leaf: Leaf) -> Callable[[LN], None]:
     """
     Factory for a convenience function that is used to orphan @string_leaf
     and then insert multiple new leaves into the same part of the node
     structure that @string_leaf had originally occupied.
 
     Examples:
         Let `string_leaf = Leaf(token.STRING, '"foo"')` and `N =
         string_leaf.parent`. Assume the node `N` has the following
         original structure:
 
         Node(
             expr_stmt, [
                 Leaf(NAME, 'x'),
                 Leaf(EQUAL, '='),
                 Leaf(STRING, '"foo"'),
             ]
         )
 
         We then run the code snippet shown below.
         ```
         insert_str_child = insert_str_child_factory(string_leaf)
 
         lpar = Leaf(token.LPAR, '(')
         insert_str_child(lpar)
 
         bar = Leaf(token.STRING, '"bar"')
         insert_str_child(bar)
 
         rpar = Leaf(token.RPAR, ')')
         insert_str_child(rpar)
         ```
 
         After which point, it follows that `string_leaf.parent is None` and
         the node `N` now has the following structure:
 
         Node(
             expr_stmt, [
                 Leaf(NAME, 'x'),
                 Leaf(EQUAL, '='),
                 Leaf(LPAR, '('),
                 Leaf(STRING, '"bar"'),
                 Leaf(RPAR, ')'),
             ]
         )
     """
 
 
 
 
 
 
 def has_triple_quotes(string: str) -> bool:
     """
     Returns:
         True iff @string starts with three quotation characters.
     """
 
 
 def parent_type(node: Optional[LN]) -> Optional[NodeType]:
     """
     Returns:
         @node.parent.type, if @node is not None and has a parent.
             OR
         None, otherwise.
     """
 
 
 
 def is_empty_par(leaf: Leaf) -> bool:
 
 
 def is_empty_lpar(leaf: Leaf) -> bool:
 
 
 def is_empty_rpar(leaf: Leaf) -> bool:
 
 
 def is_valid_index_factory(seq: Sequence[Any]) -> Callable[[int], bool]:
     """
     Examples:
         ```
         my_list = [1, 2, 3]
 
         is_valid_index = is_valid_index_factory(my_list)
 
         assert is_valid_index(0)
         assert is_valid_index(2)
 
         assert not is_valid_index(3)
         assert not is_valid_index(-1)
         ```
     """
 
 
 
 
 def line_to_string(line: Line) -> str:
     """Returns the string representation of @line.
 
     WARNING: This is known to be computationally expensive.
     """
 
 
 def append_leaves(new_line: Line, old_line: Line, leaves: List[Leaf]) -> None:
     """
     Append leaves (taken from @old_line) to @new_line, making sure to fix the
     underlying Node structure where appropriate.
 
     All of the leaves in @leaves are duplicated. The duplicates are then
     appended to @new_line and used to replace their originals in the underlying
     Node structure. Any comments attatched to the old leaves are reattached to
     the new leaves.
 
     Pre-conditions:
         set(@leaves) is a subset of set(@old_line.leaves).
     """
 
 
 
 
 def replace_child(old_child: LN, new_child: LN) -> None:
     """
     Side Effects:
         * If @old_child.parent is set, replace @old_child with @new_child in
         @old_child's underlying Node structure.
             OR
         * Otherwise, this function does nothing.
     """
 
 
 
 def get_string_prefix(string: str) -> str:
     """
     Pre-conditions:
         * assert_is_leaf_string(@string)
 
     Returns:
         @string's prefix (e.g. '', 'r', 'f', or 'rf').
     """
 
 
 
 
 def assert_is_leaf_string(string: str) -> None:
     """
     Checks the pre-condition that @string has the format that you would expect
     of `leaf.value` where `leaf` is some Leaf such that `leaf.type ==
     token.STRING`. A more precise description of the pre-conditions that are
     checked are listed below.
 
     Pre-conditions:
         * @string starts with either ', ", <prefix>', or <prefix>" where
         `set(<prefix>)` is some subset of `set(STRING_PREFIX_CHARS)`.
         * @string ends with a quote character (' or ").
 
     Raises:
         AssertionError(...) if the pre-conditions listed above are not
         satisfied.
     """
 
 
 
 def left_hand_split(line: Line, _features: Collection[Feature] = ()) -> Iterator[Line]:
     """Split line into many lines, starting with the first matching bracket pair.
 
     Note: this usually looks weird, only use this for function definitions.
     Prefer RHS otherwise.  This is why this function is not symmetrical with
     :func:`right_hand_split` which also handles optional parentheses.
     """
 
 
 
 def right_hand_split(
     line: Line,
     line_length: int,
     features: Collection[Feature] = (),
     omit: Collection[LeafID] = (),
 ) -> Iterator[Line]:
     """Split line into many lines, starting with the last matching bracket pair.
 
     If the split was by optional parentheses, attempt splitting without them, too.
     `omit` is a collection of closing bracket IDs that shouldn't be considered for
     this split.
 
     Note: running this function modifies `bracket_depth` on the leaves of `line`.
     """
         # If there is no opening or closing_bracket that means the split failed and
         # all content is in the tail.  Otherwise, if `head_leaves` are empty, it means
         # the matching `opening_bracket` wasn't available on `line` anymore.
 
         # the body shouldn't be exploded
         # the opening bracket is an optional paren
         # the closing bracket is an optional paren
         # it's not an import (optional parens are the only thing we can split on
         # in this case; attempting a split without them is a waste of time)
         # there are no standalone comments in the body
         # and we can actually remove the parens
 
 
 
 
 
 def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:
     """Raise :exc:`CannotSplit` if the last left- or right-hand split failed.
 
     Do nothing otherwise.
 
     A left- or right-hand split is based on a pair of brackets. Content before
     (and including) the opening bracket is left on one line, content inside the
     brackets is put on a separate line, and finally content starting with and
     following the closing bracket is put on a separate line.
 
     Those are called `head`, `body`, and `tail`, respectively. If the split
     produced the same line (all content in `head`) or ended up with an empty `body`
     and the `tail` is just the closing bracket, then it's considered failed.
     """
 
 
 
 def bracket_split_build_line(
     leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
 ) -> Line:
     """Return a new line with given `leaves` and respective comments from `original`.
 
     If `is_body` is True, the result line is one-indented inside brackets and as such
     has its first leaf's prefix normalized and a trailing comma added when expected.
     """
             # Since body is a new indent level, remove spurious leading whitespace.
             # Ensure a trailing comma for imports and standalone function arguments, but
             # be careful not to add one after any comments or within type annotations.
 
 
 
     # Populate the line
 
 
 def dont_increase_indentation(split_func: Transformer) -> Transformer:
     """Normalize prefix of the first leaf in every line returned by `split_func`.
 
     This is a decorator over relevant split functions.
     """
 
     @wraps(split_func)
     def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
 
     return split_wrapper
 
 
 @dont_increase_indentation
 def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
     """Split according to delimiters of the highest priority.
 
     If the appropriate Features are given, the split will add trailing commas
     also in function signatures and calls that contain `*` and `**`.
     """
 
 
 
 
 
 
 
 
 
 
 
 
 @dont_increase_indentation
 def standalone_comment_split(
     line: Line, features: Collection[Feature] = ()
 ) -> Iterator[Line]:
     """Split standalone comments from the rest of the line."""
 
 
 
 
 
 
 
 
 def is_import(leaf: Leaf) -> bool:
     """Return True if the given leaf starts an import statement."""
 
 
 def is_type_comment(leaf: Leaf, suffix: str = "") -> bool:
     """Return True if the given leaf is a special comment.
     Only returns true for type comments for now."""
 
 
 def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
     """Leave existing extra newlines if not `inside_brackets`. Remove everything
     else.
 
     Note: don't use backslashes for formatting or you'll lose your voting rights.
     """
 
 
 
 def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
     """Make all string prefixes lowercase.
 
     If remove_u_prefix is given, also removes any u prefix from the string.
 
     Note: Mutates its argument.
     """
 
 
 def normalize_string_quotes(leaf: Leaf) -> None:
     """Prefer double quotes but only if it doesn't cause more escaping.
 
     Adds or removes backslashes as appropriate. Doesn't parse and fix
     strings nested in f-strings (yet).
 
     Note: Mutates its argument.
     """
 
 
             # There's at least one unescaped new_quote in this raw string
             # so converting is impossible
 
         # Do not introduce or remove backslashes in raw strings
         # remove unnecessary escapes
             # Consider the string without unnecessary escapes as the original
                 # Do not introduce backslashes in interpolated expressions
 
         # edge case:
 
 
 
 
 def normalize_numeric_literal(leaf: Leaf) -> None:
     """Normalizes numeric (float, int, and complex) literals.
 
     All letters used in the representation are normalized to lowercase (except
     in Python 2 long literals).
     """
         # Leave octal and binary literals alone.
         # Change hex literals to upper case.
         # Capitalize in "2L" because "l" looks too similar to "1".
 
 
 def format_float_or_int_string(text: str) -> str:
     """Formats a float string like "1.0"."""
 
 
 
 def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
     """Make existing optional parentheses invisible or create new ones.
 
     `parens_after` is a set of string leaf values immediately after which parens
     should be put.
 
     Standardizes on visible parentheses for single-element tuples, and keeps
     existing visible parentheses for other tuples and generator expressions.
     """
             # This `node` has a prefix with `# fmt: off`, don't mess with parens.
         # Fixes a bug where invisible parens are not properly stripped from
         # assignment statements that contain type annotations.
 
         # Add parentheses around long tuple unpacking in assignments.
 
 
                 # "import from" nodes store parentheses directly as part of
                 # the statement
                     # make parentheses invisible
                     # insert invisible parentheses
 
 
 
 
 def normalize_fmt_off(node: Node) -> None:
     """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
 
 
 def convert_one_fmt_off_pair(node: Node) -> bool:
     """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
 
     Returns True if a pair was converted.
     """
                 # We only want standalone comments. If there's no previous leaf or
                 # the previous leaf is indentation, it's a standalone comment in
                 # disguise.
 
 
                     # That happens when one of the `ignored_nodes` ended with a NEWLINE
                     # leaf (possibly followed by a DEDENT).
 
 
 
 
 def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
     """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
 
     Stops at the end of the block.
     """
 
         # fix for fmt: on in children
 
 
 def fmt_on(container: LN) -> bool:
 
 
 def contains_fmt_on_at_column(container: LN, column: int) -> bool:
 
 
 
 def first_leaf_column(node: Node) -> Optional[int]:
 
 
 def maybe_make_parens_invisible_in_atom(node: LN, parent: LN) -> bool:
     """If it's safe, make the parens in the atom `node` invisible, recursively.
     Additionally, remove repeated, adjacent invisible parens from the atom `node`
     as they are redundant.
 
     Returns whether the node should itself be wrapped in invisible parentheses.
 
     """
 
         # make parentheses invisible
 
             # Strip the invisible parens from `middle` by replacing
             # it with the child in-between the invisible parens
 
 
 
 
 def is_atom_with_invisible_parens(node: LN) -> bool:
     """Given a `LN`, determines whether it's an atom `node` with invisible
     parens. Useful in dedupe-ing and normalizing parens.
     """
 
 
 
 def is_empty_tuple(node: LN) -> bool:
     """Return True if `node` holds an empty tuple."""
 
 
 def unwrap_singleton_parenthesis(node: LN) -> Optional[LN]:
     """Returns `wrapped` if `node` is of the shape ( wrapped ).
 
     Parenthesis can be optional. Returns None otherwise"""
 
 
 
 
 def wrap_in_parentheses(parent: Node, child: LN, *, visible: bool = True) -> None:
     """Wrap `child` in parentheses.
 
     This replaces `child` with an atom holding the parentheses and the old
     child.  That requires moving the prefix.
 
     If `visible` is False, the leaves will be valueless (and thus invisible).
     """
 
 
 def is_one_tuple(node: LN) -> bool:
     """Return True if `node` holds a tuple with one element, with or without parens."""
 
 
 
 
 def is_walrus_assignment(node: LN) -> bool:
     """Return True iff `node` is of the shape ( test := test )"""
 
 
 def is_yield(node: LN) -> bool:
     """Return True if `node` holds a `yield` or `yield from` expression."""
 
 
 
 
 
 
 
 def is_vararg(leaf: Leaf, within: Set[NodeType]) -> bool:
     """Return True if `leaf` is a star or double star in a vararg or kwarg.
 
     If `within` includes VARARGS_PARENTS, this applies to function signatures.
     If `within` includes UNPACKING_PARENTS, it applies to right hand-side
     extended iterable unpacking (PEP 3132) and additional unpacking
     generalizations (PEP 448).
     """
 
         # Star expressions are also used as assignment targets in extended
         # iterable unpacking (PEP 3132).  See what its parent is instead.
 
 
 
 
 def is_multiline_string(leaf: Leaf) -> bool:
     """Return True if `leaf` is a multiline string that actually spans many lines."""
 
 
 def is_stub_suite(node: Node) -> bool:
     """Return True if `node` is a suite with a stub body."""
 
 
 
 def is_stub_body(node: LN) -> bool:
     """Return True if `node` is a simple statement containing an ellipsis."""
 
 
 
 
 def max_delimiter_priority_in_atom(node: LN) -> Priority:
     """Return maximum delimiter priority inside `node`.
 
     This is specific to atoms with contents contained in a pair of parentheses.
     If `node` isn't an atom or there are no enclosing parentheses, returns 0.
     """
 
 
 
 
 
 def ensure_visible(leaf: Leaf) -> None:
     """Make sure parentheses are visible.
 
     They could be invisible as part of some statements (see
     :func:`normalize_invisible_parens` and :func:`visit_import_from`).
     """
 
 
 def should_explode(line: Line, opening_bracket: Leaf) -> bool:
     """Should `line` immediately be split with `delimiter_split()` after RHS?"""
 
 
 
 
 
 def get_features_used(node: Node) -> Set[Feature]:
     """Return a set of (relatively) new Python features used in this file.
 
     Currently looking for:
     - f-strings;
     - underscores in numeric literals;
     - trailing commas after * or ** in function signatures and calls;
     - positional only arguments in function signatures and lambdas;
     """
 
 
 
 
 
 
 
 
 
 def detect_target_versions(node: Node) -> Set[TargetVersion]:
     """Detect the version to target based on the nodes used."""
 
 
 def generate_trailers_to_omit(line: Line, line_length: int) -> Iterator[Set[LeafID]]:
     """Generate sets of closing bracket IDs that should be omitted in a RHS.
 
     Brackets can be omitted if the entire trailer up to and including
     a preceding closing bracket fits in one line.
 
     Yielded sets are cumulative (contain results of previous yields, too).  First
     set is empty.
     """
 
 
 
 
                 # Empty brackets would fail a split so treat them as "inner"
                 # brackets (e.g. only add them to the `omit` set if another
                 # pair of brackets was good enough.
 
 
 
 
 def get_future_imports(node: Node) -> Set[str]:
     """Return a set of __future__ imports in the file."""
 
 
 
 
 
 
             # Continue looking if we see a docstring; otherwise stop.
 
 
 
 
 
 
 @lru_cache()
 def get_gitignore(root: Path) -> PathSpec:
     """ Return a PathSpec matching gitignore content if present."""
     gitignore = root / ".gitignore"
     lines: List[str] = []
     if gitignore.is_file():
     return PathSpec.from_lines("gitwildmatch", lines)
 
 
 def gen_python_files_in_dir(
     path: Path,
     root: Path,
     include: Pattern[str],
     exclude: Pattern[str],
     report: "Report",
     gitignore: PathSpec,
 ) -> Iterator[Path]:
     """Generate all files under `path` whose paths are not excluded by the
     `exclude` regex, but are included by the `include` regex.
 
     Symbolic links pointing outside of the `root` directory are ignored.
 
     `report` is where output about exclusions goes.
     """
     assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
     for child in path.iterdir():
         # First ignore files matching .gitignore
         if gitignore.match_file(child.as_posix()):
 
         # Then ignore with `exclude` option.
         try:
             normalized_path = "/" + child.resolve().relative_to(root).as_posix()
 
 
 
         if child.is_dir():
 
         exclude_match = exclude.search(normalized_path)
         if exclude_match and exclude_match.group(0):
 
         if child.is_dir():
 
         elif child.is_file():
             include_match = include.search(normalized_path)
             if include_match:
                 yield child
 
 
 @lru_cache()
 def find_project_root(srcs: Iterable[str]) -> Path:
     """Return a directory containing .git, .hg, or pyproject.toml.
 
     That directory can be one of the directories passed in `srcs` or their
     common parent.
 
     If no directory in the tree contains a marker that would specify it's the
     project root, the root of the file system is returned.
     """
     if not srcs:
 
     common_base = min(Path(src).resolve() for src in srcs)
     if common_base.is_dir():
         # Append a fake file so `parents` below returns `common_base_dir`, too.
         common_base /= "fake-file"
     for directory in common_base.parents:
         if (directory / ".git").exists():
 
         if (directory / ".hg").is_dir():
 
         if (directory / "pyproject.toml").is_file():
 
     return directory
 
 
 @dataclass
 class Report:
     """Provides a reformatting counter. Can be rendered with `str(report)`."""
 
     check: bool = False
     diff: bool = False
     quiet: bool = False
     verbose: bool = False
     change_count: int = 0
     same_count: int = 0
     failure_count: int = 0
 
     def done(self, src: Path, changed: Changed) -> None:
         """Increment the counter for successful reformatting. Write out a message."""
 
     def failed(self, src: Path, message: str) -> None:
         """Increment the counter for failed reformatting. Write out a message."""
 
     def path_ignored(self, path: Path, message: str) -> None:
 
     @property
     def return_code(self) -> int:
         """Return the exit code that the app should use.
 
         This considers the current state of changed files and failures:
         - if there were any failures, return 123;
         - if any files were changed and --check is being used, return 1;
         - otherwise return 0.
         """
         # According to http://tldp.org/LDP/abs/html/exitcodes.html starting with
         # 126 we have special return codes reserved by the shell.
 
 
 
     def __str__(self) -> str:
         """Render a color report of the current state.
 
         Use `click.unstyle` to remove colors.
         """
 
 
 def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:
         # TODO: support Python 4+ ;)
 
 
 
 def _fixup_ast_constants(
     node: Union[ast.AST, ast3.AST, ast27.AST]
 ) -> Union[ast.AST, ast3.AST, ast27.AST]:
     """Map ast nodes deprecated in 3.8 to Constant."""
 
 
 
 
 
 def _stringify_ast(
     node: Union[ast.AST, ast3.AST, ast27.AST], depth: int = 0
 ) -> Iterator[str]:
     """Simple visitor generating strings to compare ASTs by content."""
 
 
 
         # TypeIgnore has only one field 'lineno' which breaks this comparison
 
 
 
                 # Ignore nested tuples within del statements, because we may insert
                 # parentheses and they change the AST.
 
 
 
             # Constant strings may be indented across newlines, if they are
             # docstrings; fold spaces after newlines when comparing
 
 
 
 def assert_equivalent(src: str, dst: str) -> None:
     """Raise AssertionError if `src` and `dst` aren't equivalent."""
 
 
 
 
 def assert_stable(src: str, dst: str, mode: Mode) -> None:
     """Raise AssertionError if `dst` reformats differently the second time."""
 
 
 @mypyc_attr(patchable=True)
 def dump_to_file(*output: str) -> str:
     """Dump `output` to a temporary file. Return path to the file."""
 
 
 @contextmanager
 def nullcontext() -> Iterator[None]:
     """Return an empty context manager.
 
     To be used like `nullcontext` in Python 3.7.
     """
 
 
 def diff(a: str, b: str, a_name: str, b_name: str) -> str:
     """Return a unified diff string between strings `a` and `b`."""
 
 
 
 def cancel(tasks: Iterable["asyncio.Task[Any]"]) -> None:
     """asyncio signal handler that cancels all `tasks` and reports to stderr."""
 
 
 def shutdown(loop: asyncio.AbstractEventLoop) -> None:
     """Cancel all pending tasks on `loop`, wait for them, and close the loop."""
         # This part is borrowed from asyncio/runners.py in Python 3.7b2.
 
         # `concurrent.futures.Future` objects cannot be cancelled once they
         # are already running. There might be some when the `shutdown()` happened.
         # Silence their logger's spew about the event loop being closed.
 
 
 def sub_twice(regex: Pattern[str], replacement: str, original: str) -> str:
     """Replace `regex` with `replacement` twice on `original`.
 
     This is used by string normalization to perform replaces on
     overlapping matches.
     """
 
 
 def re_compile_maybe_verbose(regex: str) -> Pattern[str]:
     """Compile a regular expression string in `regex`.
 
     If it contains newlines, use verbose mode.
     """
     if "\n" in regex:
     compiled: Pattern[str] = re.compile(regex)
     return compiled
 
 
 def enumerate_reversed(sequence: Sequence[T]) -> Iterator[Tuple[Index, T]]:
     """Like `reversed(enumerate(sequence))` if that were possible."""
 
 
 def enumerate_with_length(
     line: Line, reversed: bool = False
 ) -> Iterator[Tuple[Index, Leaf, int]]:
     """Return an enumeration of leaves with their length.
 
     Stops prematurely on multiline strings and standalone comments.
     """
 
 
 
 
 def is_line_short_enough(line: Line, *, line_length: int, line_str: str = "") -> bool:
     """Return True if `line` is no longer than `line_length`.
 
     Uses the provided `line_str` rendering, if any, otherwise computes a new one.
     """
 
 
 def can_be_split(line: Line) -> bool:
     """Return False if the line cannot be split *for sure*.
 
     This is not an exhaustive search but a cheap heuristic that we can use to
     avoid some unfortunate formattings (mostly around wrapping unsplittable code
     in unnecessary parentheses).
     """
 
 
 
 
 
 
 
 def can_omit_invisible_parens(line: Line, line_length: int) -> bool:
     """Does `line` have a shape safe to reformat without optional parens around it?
 
     Returns True for only a subset of potentially nice looking formattings but
     the point is to not return false positives that end up producing lines that
     are too long.
     """
         # Without delimiters the optional parentheses are useless.
 
         # With more than one delimiter of a kind the optional parentheses read better.
 
         # A single stranded method call doesn't require optional parentheses.
 
 
 
     # With a single delimiter, omit if the expression starts or ends with
     # a bracket.
 
                     # There are brackets we can further split on.
 
             # checked the entire string and line length wasn't exceeded
 
         # Note: we are not returning False here because a line might have *both*
         # a leading opening bracket and a trailing closing bracket.  If the
         # opening bracket doesn't match our rule, maybe the closing will.
 
             # don't use indexing for omitting optional parentheses;
             # it looks weird
             # Empty brackets don't help.
 
             # Additional wrapping of a multiline string in this situation is
             # unnecessary.
 
 
                 # There are brackets we can further split on.
 
 
 
 def get_cache_file(mode: Mode) -> Path:
     return CACHE_DIR / f"cache.{mode.get_cache_key()}.pickle"
 
 
 def read_cache(mode: Mode) -> Cache:
     """Read the cache if it exists and is well formed.
 
     If it is not well formed, the call to write_cache later should resolve the issue.
     """
 
 
 
 
 def get_cache_info(path: Path) -> CacheInfo:
     """Return the information used to check if a file is already formatted or not."""
     stat = path.stat()
     return stat.st_mtime, stat.st_size
 
 
 def filter_cached(cache: Cache, sources: Iterable[Path]) -> Tuple[Set[Path], Set[Path]]:
     """Split an iterable of paths in `sources` into two sets.
 
     The first contains paths of files that modified on disk or are not in the
     cache. The other contains paths to non-modified files.
     """
 
 
 def write_cache(cache: Cache, sources: Iterable[Path], mode: Mode) -> None:
     """Update the cache file."""
     cache_file = get_cache_file(mode)
     try:
         CACHE_DIR.mkdir(parents=True, exist_ok=True)
         new_cache = {**cache, **{src.resolve(): get_cache_info(src) for src in sources}}
         with tempfile.NamedTemporaryFile(dir=str(cache_file.parent), delete=False) as f:
             pickle.dump(new_cache, f, protocol=4)
         os.replace(f.name, cache_file)
 
 
 def patch_click() -> None:
     """Make Click not crash.
 
     On certain misconfigured environments, Python 3 selects the ASCII encoding as the
     default which restricts paths that it can access during the lifetime of the
     application.  Click refuses to work in this scenario by raising a RuntimeError.
 
     In case of Black the likelihood that non-ASCII characters are going to be used in
     file paths is minimal since it's Python source code.  Moreover, this crash was
     spurious on Python 3.7 thanks to PEP 538 and PEP 540.
     """
 
 
 
 def patched_main() -> None:
 
 
 def fix_docstring(docstring: str, prefix: str) -> str:
     # https://www.python.org/dev/peps/pep-0257/#handling-docstring-indentation
     # Convert tabs to spaces (following the normal Python rules)
     # and split into a list of lines:
     # Determine minimum indentation (first line doesn't count):
     # Remove indentation (first line is special):
     # Return a single string:
 
 
 if __name__ == "__main__":
